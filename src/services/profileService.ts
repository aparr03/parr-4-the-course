import { supabase } from '../lib/supabase';

// Define Profile type
export interface Profile {
  id: string;
  username: string;
  avatar_url?: string;
  created_at: string;
  is_admin?: boolean;
}

// Debug mode toggle - set to true to enable detailed logging
const DEBUG_PROFILE = true;

// Define bucket name in one place for easy changes
const AVATAR_BUCKET = 'avatars';

/**
 * Debug log function to consistently format profile-related logs
 */
const debugLog = (action: string, data: any) => {
  if (DEBUG_PROFILE) {
    console.log(`[PROFILE][${action}]`, data);
  }
};

export const profileService = {
  /**
   * Create a new user profile
   */
  async createProfile(userId: string, username: string) {
    debugLog('CREATE_PROFILE', { userId, username });
    
    // First check if profile already exists to avoid conflicts
    const { data: existingProfile } = await this.getProfileByUserId(userId);
    
    if (existingProfile) {
      debugLog('PROFILE_EXISTS', { 
        userId, 
        existingUsername: existingProfile.username 
      });
      
      // If profile exists with auto-generated username, update it
      if (existingProfile.username && existingProfile.username.startsWith('user_')) {
        debugLog('UPDATING_AUTOGENERATED', { 
          from: existingProfile.username, 
          to: username 
        });
        
        return this.updateProfile(userId, { username });
      }
      
      // Otherwise return existing profile
      return { data: existingProfile, error: null };
    }
    
    // Create new profile
    try {
      const result = await supabase
        .from('profiles')
        .insert({
          id: userId,
          username
        })
        .select()
        .single();
      
      debugLog('PROFILE_CREATED', { 
        userId, 
        username, 
        success: !result.error,
        error: result.error
      });
      
      return result;
    } catch (error) {
      debugLog('CREATE_PROFILE_ERROR', { userId, username, error });
      throw error;
    }
  },
  
  /**
   * Get a profile by user ID
   */
  async getProfileByUserId(userId: string) {
    try {
      // Check if this profile exists
      const { data, error } = await supabase
        .from('profiles')
        .select('*')
        .eq('id', userId);
      
      // If profile exists, return it
      if (!error && data && data.length > 0) {
        return { data: data[0], error: null };
      }
      
      // If no data but no error, just return null data
      if (!error) {
        return { data: null, error: null };
      }
      
      // If there was an error with the query
      return { data: null, error };
    } catch (error) {
      console.error('Error in getProfileByUserId:', error);
      return { data: null, error };
    }
  },
  
  /**
   * Get a user ID by username
   */
  async getUserIdByUsername(username: string) {
    return supabase
      .from('profiles')
      .select('id')
      .eq('username', username)
      .single();
  },
  
  /**
   * Check if a username is available
   */
  async isUsernameAvailable(username: string) {
    const { data, error } = await supabase
      .from('profiles')
      .select('username')
      .eq('username', username);
    
    // If no error and data array is empty, username is available
    if (!error && (!data || data.length === 0)) {
      return { available: true, error: null };
    }
    
    // If data exists, username is taken
    if (data && data.length > 0) {
      return { available: false, error: null };
    }
    
    // If there's an error, log it and return false
    console.error('Error checking username availability:', error);
    return { available: false, error };
  },
  
  /**
   * Update user profile
   */
  async updateProfile(userId: string, updates: Partial<Omit<Profile, 'id' | 'created_at'>>): Promise<{
    data: Profile | null;
    error: any | null;
  }> {
    try {
      debugLog('UPDATE_PROFILE', { userId, updates });
      
      // This is a workaround for 406 errors
      // First check if the profile exists
      const { data: existingProfile, error: fetchError } = await this.getProfileByUserId(userId);
      
      if (fetchError) {
        debugLog('UPDATE_PROFILE_FETCH_ERROR', { userId, error: fetchError });
        return { data: null, error: fetchError };
      }
      
      if (!existingProfile) {
        // If profile doesn't exist, create it
        debugLog('PROFILE_NOT_FOUND_CREATING', { userId, updates });
        return this.createProfile(userId, updates.username || `user_${userId.substring(0, 8)}`);
      }
      
      // If here, profile exists, attempt update
      const { data, error } = await supabase
        .from('profiles')
        .update(updates)
        .eq('id', userId)
        .select()
        .single();
      
      if (error) {
        debugLog('UPDATE_PROFILE_ERROR', { userId, updates, error });
        
        // If update fails with 406, try an upsert operation
        if (error.code === '406') {
          debugLog('ATTEMPTING_UPSERT_AFTER_406', { userId, updates });
          
          // Combine existing profile with updates
          const profileWithUpdates = { ...existingProfile, ...updates };
          
          const { data: upsertResult, error: upsertError } = await supabase
            .from('profiles')
            .upsert(profileWithUpdates)
            .select()
            .single();
          
          if (upsertError) {
            debugLog('UPSERT_FAILED', { userId, error: upsertError });
            return { data: null, error: upsertError };
          }
          
          debugLog('UPSERT_SUCCESSFUL', { userId, data: upsertResult });
          return { data: upsertResult, error: null };
        }
        
        return { data: null, error };
      }
      
      debugLog('UPDATE_PROFILE_SUCCESS', { userId, data });
      return { data, error: null };
    } catch (error) {
      debugLog('UPDATE_PROFILE_EXCEPTION', { userId, updates, error });
      return { data: null, error };
    }
  },

  /**
   * Upload a profile picture
   */
  async uploadAvatar(userId: string, file: File) {
    try {
      // Create a unique file path for the user's avatar
      const filePath = `${userId}/${Math.random().toString(36).substring(2)}`;
      
      // Create log object for consolidated logging
      const logInfo = {
        action: 'avatar_upload',
        userId,
        filePath: `${AVATAR_BUCKET}/${filePath}`,
        steps: [] as {step: string, status: string, data?: any, error?: any}[]
      };
      
      // Add upload step
      logInfo.steps.push({step: 'upload_start', status: 'pending'});
      
      // Upload the file to Supabase Storage
      const { error } = await supabase.storage
        .from(AVATAR_BUCKET)
        .upload(filePath, file, {
          upsert: true,
          cacheControl: '3600'
        });
      
      if (error) {
        logInfo.steps[0].status = 'error';
        logInfo.steps[0].error = error;
        console.error('Avatar upload process:', logInfo);
        throw error;
      }
      
      logInfo.steps[0].status = 'success';
      
      // Add URL generation step
      logInfo.steps.push({step: 'get_url', status: 'pending'});
      
      // Try to get a signed URL (temporary but should work)
      try {
        const { data: signedData } = await supabase.storage
          .from(AVATAR_BUCKET)
          .createSignedUrl(filePath, 60 * 60 * 24 * 365); // 1 year expiry
          
        if (signedData && signedData.signedUrl) {
          logInfo.steps[1].status = 'success';
          logInfo.steps[1].data = { urlType: 'signed', signedUrl: signedData.signedUrl };
          
          // Add profile update step
          logInfo.steps.push({step: 'update_profile', status: 'pending'});
          
          // Update the user's profile with the signed URL
          const { error: updateError } = await supabase
            .from('profiles')
            .update({ avatar_url: signedData.signedUrl })
            .eq('id', userId);
            
          if (updateError) {
            logInfo.steps[2].status = 'error';
            logInfo.steps[2].error = updateError;
            console.error('Avatar upload process:', logInfo);
            throw updateError;
          }
          
          logInfo.steps[2].status = 'success';
          console.log('Avatar upload process:', logInfo);
          
          return { publicUrl: signedData.signedUrl };
        }
      } catch (signError) {
        logInfo.steps[1].status = 'error';
        logInfo.steps[1].error = signError;
        logInfo.steps.push({step: 'fallback_to_public_url', status: 'pending'});
        // Fall back to public URL
      }
      
      // Get the public URL as fallback
      const { data: { publicUrl } } = supabase.storage
        .from(AVATAR_BUCKET)
        .getPublicUrl(filePath);
      
      if (logInfo.steps.length === 2) {
        logInfo.steps[1].status = 'success';
        logInfo.steps[1].data = { urlType: 'public', publicUrl };
        logInfo.steps.push({step: 'update_profile', status: 'pending'});
      } else {
        logInfo.steps[2].status = 'success';
        logInfo.steps.push({step: 'update_profile', status: 'pending'});
      }
      
      // Update the user's profile with the public URL as fallback
      const { error: updateError } = await supabase
        .from('profiles')
        .update({ avatar_url: publicUrl })
        .eq('id', userId);
      
      if (updateError) {
        logInfo.steps[logInfo.steps.length - 1].status = 'error';
        logInfo.steps[logInfo.steps.length - 1].error = updateError;
        console.error('Avatar upload process:', logInfo);
        throw updateError;
      }
      
      logInfo.steps[logInfo.steps.length - 1].status = 'success';
      console.log('Avatar upload process:', logInfo);
      
      return { publicUrl };
    } catch (error) {
      console.error('Avatar upload error:', {
        userId,
        bucket: AVATAR_BUCKET,
        error: error instanceof Error ? error.message : error
      });
      throw error;
    }
  },

  /**
   * Delete a profile picture
   */
  async deleteAvatar(userId: string, filePath: string) {
    // Remove the file from storage
    const { error: deleteError } = await supabase.storage
      .from(AVATAR_BUCKET)
      .remove([filePath]);
    
    if (deleteError) {
      throw deleteError;
    }
    
    // Update the profile to remove the avatar reference
    const { error: updateError } = await supabase
      .from('profiles')
      .update({ avatar_url: null })
      .eq('id', userId);
    
    if (updateError) {
      throw updateError;
    }
    
    return { success: true };
  },

  /**
   * Update username immediately after signup
   */
  async updateUsernameAfterSignup(userId: string, username: string) {
    try {
      debugLog('UPDATE_USERNAME_AFTER_SIGNUP', { userId, username });
      
      // First try using our secure RPC function - this is most reliable
      const { success, error: rpcError } = await this.setUsernameSecurely(userId, username);
      
      if (success) {
        debugLog('USERNAME_SET_SECURELY', { userId, username });
        
        // Get the profile data to return
        const { data, error } = await this.getProfileByUserId(userId);
        
        if (error) {
          debugLog('PROFILE_FETCH_ERROR_AFTER_SECURE_UPDATE', { userId, error });
          return { data: null, error };
        }
        
        return { data, error: null };
      }
      
      // If secure method failed, continue with traditional approach
      debugLog('SECURE_UPDATE_FAILED_TRYING_STANDARD', { userId, username, error: rpcError });
      
      // First check if a profile already exists for this user
      const { data: existingProfile, error: fetchError } = await supabase
        .from('profiles')
        .select('username')
        .eq('id', userId)
        .maybeSingle();
      
      debugLog('EXISTING_PROFILE_CHECK', { 
        userId, 
        existingProfile, 
        fetchError 
      });
      
      // If no profile exists yet, create one with the provided username
      if (fetchError || !existingProfile) {
        debugLog('NO_PROFILE_FOUND', { 
          userId, 
          error: fetchError, 
          creatingWith: username 
        });
        
        // Try 3 times with delay to ensure the operation succeeds
        let attempt = 0;
        let lastError = null;
        
        while (attempt < 3) {
          try {
            attempt++;
            
            // Add increasing delay between attempts
            if (attempt > 1) {
              await new Promise(resolve => setTimeout(resolve, attempt * 500));
            }
            
            const { data, error } = await supabase
              .from('profiles')
              .insert({ id: userId, username })
              .select()
              .single();
            
            if (error) {
              debugLog('PROFILE_CREATION_ATTEMPT_FAILED', { 
                userId, 
                username, 
                attempt, 
                error 
              });
              lastError = error;
              continue;
            }
            
            debugLog('PROFILE_CREATED_SUCCESSFULLY', { 
              userId, 
              username, 
              attempt, 
              profile: data 
            });
            return { data, error: null };
          } catch (err) {
            lastError = err;
            debugLog('PROFILE_CREATION_EXCEPTION', { 
              userId, 
              username, 
              attempt, 
              error: err 
            });
          }
        }
        
        // If we've exhausted all attempts, return the last error
        console.error('Failed to create profile after multiple attempts:', lastError);
        return { data: null, error: lastError };
      }
      
      // If profile exists with an auto-generated username or empty username, update it
      if (!existingProfile.username || existingProfile.username.startsWith('user_')) {
        debugLog('UPDATING_AUTO_USERNAME', {
          userId,
          oldUsername: existingProfile.username,
          newUsername: username
        });
        
        // Force update the username for this profile
        const { data, error } = await supabase
          .from('profiles')
          .update({ username })
          .eq('id', userId)
          .select()
          .single();
        
        if (error) {
          debugLog('USERNAME_UPDATE_FAILED', { userId, error });
          return { data: null, error };
        }
        
        debugLog('USERNAME_UPDATED_SUCCESSFULLY', { 
          userId, 
          username,
          profile: data 
        });
        
        return { data, error: null };
      }
      
      // If profile exists with a non-auto-generated username, don't overwrite it
      debugLog('KEEPING_EXISTING_USERNAME', {
        userId,
        existingUsername: existingProfile.username,
        requestedUsername: username
      });
      
      // Return the existing profile data
      return { data: existingProfile, error: null };
    } catch (error) {
      debugLog('UPDATE_USERNAME_ERROR', { userId, username, error });
      return { data: null, error };
    }
  },

  /**
   * Monitor and debug function to trace username issues
   * This can be called from various places to check if a username has been properly set
   */
  async monitorUsername(userId: string, context: string) {
    if (!DEBUG_PROFILE) return;
    
    try {
      const { data, error } = await supabase
        .from('profiles')
        .select('username, created_at')
        .eq('id', userId)
        .maybeSingle();
      
      debugLog('USERNAME_MONITOR', {
        context,
        userId,
        profile: data,
        error,
        timestamp: new Date().toISOString()
      });
      
      return { data, error };
    } catch (err) {
      debugLog('USERNAME_MONITOR_ERROR', {
        context,
        userId,
        error: err,
        timestamp: new Date().toISOString()
      });
      return { data: null, error: err };
    }
  },

  /**
   * Use RPC function to set username (bypasses RLS issues)
   */
  async setUsernameSecurely(userId: string, username: string) {
    try {
      debugLog('SET_USERNAME_SECURELY', { userId, username });
      
      // Call the RPC function that has SECURITY DEFINER privileges
      const { data, error } = await supabase
        .rpc('set_username_after_signup', {
          p_user_id: userId,
          p_username: username
        });
      
      debugLog('SET_USERNAME_RESULT', { 
        userId, 
        username, 
        success: !!data,
        error 
      });
      
      if (error) {
        return { success: false, error };
      }
      
      return { success: !!data, error: null };
    } catch (error) {
      debugLog('SET_USERNAME_ERROR', { userId, username, error });
      return { success: false, error };
    }
  },
}; 